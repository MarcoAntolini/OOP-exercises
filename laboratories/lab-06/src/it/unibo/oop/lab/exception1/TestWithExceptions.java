package it.unibo.oop.lab.exception1;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.fail;

import java.lang.reflect.InvocationTargetException;

import org.junit.Test;

/**
 * Example testing class that illustrates two possible patterns to make good
 * tests when exceptions are involved.
 */
public final class TestWithExceptions {

    /**
     * This is a test where we do not expect any exception to be generated. If
     * one exception is generated, then it must fail.
     */
    @Test
    public void testExceptionNotExpected() {
        try {
            Class.forName("java.util.ArrayList").getConstructor().newInstance();
        } catch (
            ClassNotFoundException
            | InstantiationException
            | IllegalAccessException
            | InvocationTargetException
            | NoSuchMethodException
            | SecurityException e
        ) {
            /*
             * Same behavior for any exception: use multi-catch.
             * 
             * Do not catch generic Exceptions: if they are unforeseen, it is
             * better to let the test fail badly, so that the developer is
             * informed that it is not a "normal" failure.
             */
            fail(e.getMessage());
        }
    }

    /**
     * This is a test where we do expect an exception to be raised. If not, the
     * test must fail.
     * @throws SecurityException 
     * @throws ClassNotFoundException 
     * @throws InvocationTargetException 
     * @throws IllegalArgumentException 
     * @throws IllegalAccessException 
     * @throws InstantiationException 
     */
    @Test
    public void testExceptionExpected()
            throws InstantiationException,
            IllegalAccessException,
            InvocationTargetException,
            ClassNotFoundException {
        try {
            Class.forName("java.util.List").getConstructor().newInstance();
            /*
             * If we get to the next line, then we have not generated any exception. The test must fail().
             */
            fail();
        } catch (NoSuchMethodException e) {
            /*
             * We expect this exception, and none other (List must exist in the
             * classpath, but it can't be instanced being an interface.
             * 
             * Since an empty catch block is pretty bad looking, what we can do
             * is for instance a quality check on the generated exception. In
             * this case a good quality exception will be generated by the Java
             * libraries, but if you are catching an exception thrown by some
             * less reliable library, it may be a good idea to verify that, for
             * instance:
             * 
             * - it holds a message - the message is not an empty String
             */
            assertNotNull(e.getMessage());
            assertFalse(e.getMessage().isEmpty());
        }
    }
}
